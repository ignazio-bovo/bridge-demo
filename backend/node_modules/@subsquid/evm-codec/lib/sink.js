"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Sink_instances, _Sink_u64, _Sink_u128, _Sink_i256;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sink = void 0;
const node_assert_1 = __importDefault(require("node:assert"));
const codec_1 = require("./codec");
class Sink {
    constructor(fields, capacity = 1280) {
        _Sink_instances.add(this);
        this.pos = 0;
        this.stack = [];
        this.stack.push({
            start: 0,
            jumpBackPtr: 0,
            size: fields * codec_1.WORD_SIZE,
        });
        this.buf = Buffer.alloc(capacity);
        this.view = new DataView(this.buf.buffer, this.buf.byteOffset, this.buf.byteLength);
    }
    result() {
        (0, node_assert_1.default)(this.stack.length === 1, 'Cannot get result during dynamic encoding');
        return this.buf.subarray(0, this.size());
    }
    toString() {
        return '0x' + this.result().toString('hex');
    }
    reserve(additional) {
        if (this.buf.length - this.pos < additional) {
            this._allocate(this.pos + additional);
        }
    }
    size() {
        return this.stack[this.stack.length - 1].size;
    }
    _allocate(cap) {
        cap = Math.max(cap, this.buf.length * 2);
        let buf = Buffer.alloc(cap);
        buf.set(this.buf);
        this.buf = buf;
        this.view = new DataView(this.buf.buffer, this.buf.byteOffset, this.buf.byteLength);
    }
    checkNumberBounds(val, min, max, typeName) {
        if (val < min || val > max) {
            throw new Error(`${val} is out of bounds for ${typeName}[${min}, ${max}]`);
        }
    }
    u8(val) {
        this.checkNumberBounds(val, 0n, 255n, 'uint8');
        this.reserve(codec_1.WORD_SIZE);
        this.pos += codec_1.WORD_SIZE - 1;
        this.view.setUint8(this.pos, val);
        this.pos += 1;
    }
    i8(val) {
        this.checkNumberBounds(val, -128n, 127n, 'int8');
        __classPrivateFieldGet(this, _Sink_instances, "m", _Sink_i256).call(this, BigInt(val));
    }
    u16(val) {
        this.checkNumberBounds(val, 0n, 65535n, 'uint16');
        this.reserve(codec_1.WORD_SIZE);
        this.pos += codec_1.WORD_SIZE - 2;
        this.view.setUint16(this.pos, val, false);
        this.pos += 2;
    }
    i16(val) {
        this.checkNumberBounds(val, -32768n, 32767n, 'int16');
        __classPrivateFieldGet(this, _Sink_instances, "m", _Sink_i256).call(this, BigInt(val));
    }
    u32(val) {
        this.checkNumberBounds(val, 0n, 4294967295n, 'uint32');
        this.reserve(codec_1.WORD_SIZE);
        this.pos += codec_1.WORD_SIZE - 4;
        this.view.setUint32(this.pos, val, false);
        this.pos += 4;
    }
    i32(val) {
        this.checkNumberBounds(val, -2147483648n, 2147483647n, 'int32');
        __classPrivateFieldGet(this, _Sink_instances, "m", _Sink_i256).call(this, BigInt(val));
    }
    u64(val) {
        this.checkNumberBounds(val, 0n, 18446744073709551615n, 'uint64');
        this.reserve(codec_1.WORD_SIZE);
        this.pos += codec_1.WORD_SIZE - 8;
        this.view.setBigUint64(this.pos, val, false);
        this.pos += 8;
    }
    i64(val) {
        this.checkNumberBounds(val, -9223372036854775808n, 9223372036854775807n, 'int64');
        __classPrivateFieldGet(this, _Sink_instances, "m", _Sink_i256).call(this, val);
    }
    u128(val) {
        this.checkNumberBounds(val, 0n, 340282366920938463463374607431768211455n, 'uint128');
        this.reserve(codec_1.WORD_SIZE);
        this.pos += codec_1.WORD_SIZE - 16;
        __classPrivateFieldGet(this, _Sink_instances, "m", _Sink_u64).call(this, val & 0xffffffffffffffffn);
        __classPrivateFieldGet(this, _Sink_instances, "m", _Sink_u64).call(this, val >> 64n);
    }
    i128(val) {
        this.checkNumberBounds(val, -170141183460469231731687303715884105728n, 170141183460469231731687303715884105727n, 'int128');
        __classPrivateFieldGet(this, _Sink_instances, "m", _Sink_i256).call(this, val);
    }
    u256(val) {
        this.checkNumberBounds(val, 0n, 115792089237316195423570985008687907853269984665640564039457584007913129639935n, 'uint256');
        this.reserve(codec_1.WORD_SIZE);
        __classPrivateFieldGet(this, _Sink_instances, "m", _Sink_u128).call(this, val >> 128n);
        __classPrivateFieldGet(this, _Sink_instances, "m", _Sink_u128).call(this, val & (2n ** 128n - 1n));
    }
    i256(val) {
        this.checkNumberBounds(val, -57896044618658097711785492504343953926634992332820282019728792003956564819968n, 57896044618658097711785492504343953926634992332820282019728792003956564819967n, 'int256');
        __classPrivateFieldGet(this, _Sink_instances, "m", _Sink_i256).call(this, val);
    }
    bytes(val) {
        const size = Buffer.byteLength(val);
        this.u32(size);
        const wordsCount = Math.ceil(size / codec_1.WORD_SIZE);
        const reservedSize = codec_1.WORD_SIZE * wordsCount;
        this.reserve(reservedSize);
        this.buf.set(val, this.pos);
        this.pos += reservedSize;
        this.increaseCurrentDataAreaSize(reservedSize + codec_1.WORD_SIZE);
    }
    staticBytes(len, val) {
        if (len > 32) {
            throw new Error(`bytes${len} is not a valid type`);
        }
        const size = Buffer.byteLength(val);
        if (size > len) {
            throw new Error(`invalid data size for bytes${len}`);
        }
        this.reserve(codec_1.WORD_SIZE);
        this.buf.set(val, this.pos);
        this.pos += codec_1.WORD_SIZE;
    }
    address(val) {
        this.u256(BigInt(val));
    }
    string(val) {
        const size = Buffer.byteLength(val);
        this.u32(size);
        const wordsCount = Math.ceil(size / codec_1.WORD_SIZE);
        const reservedSize = codec_1.WORD_SIZE * wordsCount;
        this.reserve(reservedSize);
        this.buf.write(val, this.pos);
        this.pos += reservedSize;
        this.increaseCurrentDataAreaSize(reservedSize + codec_1.WORD_SIZE);
    }
    bool(val) {
        this.u8(val ? 1 : 0);
    }
    /**
     * @example
     * @link [Solidity docs](https://docs.soliditylang.org/en/latest/abi-spec.html#use-of-dynamic-types)
     */
    newStaticDataArea(slotsCount = 0) {
        const offset = this.size();
        this.u32(offset);
        const dataAreaStart = this.currentDataAreaStart();
        this.pushDataArea(dataAreaStart + offset, slotsCount);
        this.pos = dataAreaStart + offset;
    }
    // Adds elements count before the data area in an additional slot
    newDynamicDataArea(slotsCount) {
        const offset = this.size();
        this.u32(offset);
        const dataAreaStart = this.currentDataAreaStart();
        this.pushDataArea(dataAreaStart + offset + codec_1.WORD_SIZE, slotsCount);
        this.pos = dataAreaStart + offset;
        this.u32(slotsCount);
    }
    currentDataAreaStart() {
        return this.stack[this.stack.length - 1].start;
    }
    increaseCurrentDataAreaSize(amount) {
        this.stack[this.stack.length - 1].size += amount;
    }
    pushDataArea(dataAreaStart, slotsCount) {
        const size = slotsCount * codec_1.WORD_SIZE;
        this.reserve(dataAreaStart + size);
        this.stack.push({
            start: dataAreaStart,
            jumpBackPtr: this.pos,
            size,
        });
    }
    endCurrentDataArea() {
        (0, node_assert_1.default)(this.stack.length > 1, 'No dynamic encoding started');
        const { jumpBackPtr, size } = this.stack.pop();
        this.increaseCurrentDataAreaSize(size);
        this.pos = jumpBackPtr;
    }
}
exports.Sink = Sink;
_Sink_instances = new WeakSet(), _Sink_u64 = function _Sink_u64(val) {
    this.view.setBigUint64(this.pos, val, false);
    this.pos += 8;
}, _Sink_u128 = function _Sink_u128(val) {
    this.reserve(codec_1.WORD_SIZE);
    __classPrivateFieldGet(this, _Sink_instances, "m", _Sink_u64).call(this, val >> 64n);
    __classPrivateFieldGet(this, _Sink_instances, "m", _Sink_u64).call(this, val & 0xffffffffffffffffn);
}, _Sink_i256 = function _Sink_i256(val) {
    let base = 2n ** 256n;
    const uval = (val + base) % base;
    this.reserve(codec_1.WORD_SIZE);
    __classPrivateFieldGet(this, _Sink_instances, "m", _Sink_u128).call(this, uval >> 128n);
    __classPrivateFieldGet(this, _Sink_instances, "m", _Sink_u128).call(this, uval & (2n ** 128n - 1n));
};
//# sourceMappingURL=sink.js.map