"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FixedSizeArrayCodec = exports.ArrayCodec = void 0;
const codec_1 = require("../codec");
class ArrayCodec {
    constructor(item) {
        this.item = item;
        this.isDynamic = true;
        this.baseType = 'array';
    }
    encode(sink, val) {
        sink.newDynamicDataArea(val.length);
        for (let i = 0; i < val.length; i++) {
            this.item.encode(sink, val[i]);
        }
        sink.increaseCurrentDataAreaSize(codec_1.WORD_SIZE);
        sink.endCurrentDataArea();
    }
    decode(src) {
        const offset = src.u32();
        src.safeJump(offset, 'array');
        const len = src.u32();
        const tmpSrc = src.slice(offset + codec_1.WORD_SIZE);
        const val = new Array(len);
        for (let i = 0; i < val.length; i++) {
            val[i] = this.item.decode(tmpSrc);
        }
        src.jumpBack();
        return val;
    }
}
exports.ArrayCodec = ArrayCodec;
class FixedSizeArrayCodec {
    constructor(item, size) {
        this.item = item;
        this.size = size;
        this.baseType = 'array';
        this.isDynamic = item.isDynamic && size > 0;
        this.slotsCount = this.isDynamic ? 1 : size;
    }
    encode(sink, val) {
        if (val.length !== this.size) {
            throw new Error(`invalid array length: ${val.length}. Expected: ${this.size}`);
        }
        if (this.isDynamic) {
            return this.encodeDynamic(sink, val);
        }
        for (let i = 0; i < this.size; i++) {
            this.item.encode(sink, val[i]);
        }
    }
    encodeDynamic(sink, val) {
        sink.newStaticDataArea(this.size);
        for (let i = 0; i < val.length; i++) {
            this.item.encode(sink, val[i]);
        }
        sink.endCurrentDataArea();
    }
    decode(src) {
        if (this.isDynamic) {
            return this.decodeDynamic(src);
        }
        let val = new Array(this.size);
        for (let i = 0; i < val.length; i++) {
            val[i] = this.item.decode(src);
        }
        return val;
    }
    decodeDynamic(src) {
        const offset = src.u32();
        const tmpSrc = src.slice(offset);
        let val = new Array(this.size);
        for (let i = 0; i < val.length; i++) {
            val[i] = this.item.decode(tmpSrc);
        }
        return val;
    }
}
exports.FixedSizeArrayCodec = FixedSizeArrayCodec;
//# sourceMappingURL=array.js.map