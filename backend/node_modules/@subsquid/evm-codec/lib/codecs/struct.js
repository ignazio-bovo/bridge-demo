"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StructCodec = void 0;
function slotsCount(codecs) {
    let count = 0;
    for (const codec of codecs) {
        count += codec.slotsCount ?? 1;
    }
    return count;
}
class StructCodec {
    constructor(components) {
        this.baseType = 'struct';
        this.components = components;
        const codecs = Object.values(components);
        this.isDynamic = codecs.some((codec) => codec.isDynamic);
        this.childrenSlotsCount = slotsCount(codecs);
        if (this.isDynamic) {
            this.slotsCount = 1;
        }
        else {
            this.slotsCount = this.childrenSlotsCount;
        }
    }
    encode(sink, val) {
        if (this.isDynamic) {
            this.encodeDynamic(sink, val);
            return;
        }
        for (let i in this.components) {
            let prop = this.components[i];
            prop.encode(sink, val[i]);
        }
    }
    encodeDynamic(sink, val) {
        sink.newStaticDataArea(this.childrenSlotsCount);
        for (let i in this.components) {
            let prop = this.components[i];
            prop.encode(sink, val[i]);
        }
        sink.endCurrentDataArea();
    }
    decode(src) {
        if (this.isDynamic) {
            return this.decodeDynamic(src);
        }
        let result = {};
        for (let i in this.components) {
            let prop = this.components[i];
            result[i] = prop.decode(src);
        }
        return result;
    }
    decodeDynamic(src) {
        let result = {};
        const offset = src.u32();
        const tmpSrc = src.slice(offset);
        for (let i in this.components) {
            let prop = this.components[i];
            result[i] = prop.decode(tmpSrc);
        }
        return result;
    }
}
exports.StructCodec = StructCodec;
//# sourceMappingURL=struct.js.map