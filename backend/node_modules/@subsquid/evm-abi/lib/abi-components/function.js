"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _AbiFunction_selector;
Object.defineProperty(exports, "__esModule", { value: true });
exports.viewFun = exports.fun = exports.AbiFunction = void 0;
const node_assert_1 = __importDefault(require("node:assert"));
const evm_codec_1 = require("@subsquid/evm-codec");
const errors_1 = require("../errors");
function slotsCount(codecs) {
    let count = 0;
    for (const codec of codecs) {
        count += codec.slotsCount ?? 1;
    }
    return count;
}
class AbiFunction {
    get sighash() {
        return this.selector;
    }
    constructor(selector, signature, args, returnType, isView = false) {
        this.selector = selector;
        this.signature = signature;
        this.args = args;
        this.returnType = returnType;
        this.isView = isView;
        _AbiFunction_selector.set(this, void 0);
        (0, node_assert_1.default)(selector.startsWith('0x'), 'selector must start with 0x');
        (0, node_assert_1.default)(selector.length === 10, 'selector must be 4 bytes long');
        __classPrivateFieldSet(this, _AbiFunction_selector, Buffer.from(selector.slice(2), 'hex'), "f");
        this.args = args;
        this.slotsCount = slotsCount(Object.values(args));
    }
    is(calldata) {
        return this.checkSignature(typeof calldata === 'string' ? calldata : calldata.input);
    }
    encode(args) {
        const sink = new evm_codec_1.Sink(this.slotsCount);
        for (let i in this.args) {
            this.args[i].encode(sink, args[i]);
        }
        return `0x${Buffer.concat([__classPrivateFieldGet(this, _AbiFunction_selector, "f"), sink.result()]).toString('hex')}`;
    }
    decode(calldata) {
        const input = typeof calldata === 'string' ? calldata : calldata.input;
        if (!this.checkSignature(input)) {
            throw new errors_1.FunctionInvalidSignatureError({ targetSig: this.selector, sig: input.slice(0, this.selector.length) });
        }
        const src = new evm_codec_1.Src(Buffer.from(input.slice(10), 'hex'));
        const result = {};
        for (let i in this.args) {
            try {
                result[i] = this.args[i].decode(src);
            }
            catch (e) {
                throw new errors_1.FunctionCalldataDecodeError(this.signature, i, e.message, input);
            }
        }
        return result;
    }
    isCodecs(value) {
        return 'decode' in value && 'encode' in value;
    }
    decodeResult(output) {
        if (!this.returnType) {
            return undefined;
        }
        const src = new evm_codec_1.Src(Buffer.from(output.slice(2), 'hex'));
        if (this.isCodecs(this.returnType)) {
            try {
                return this.returnType.decode(src);
            }
            catch (e) {
                throw new errors_1.FunctionResultDecodeError(this.signature, '', e.message, output);
            }
        }
        const result = {};
        for (let i in this.returnType) {
            const codec = this.returnType[i];
            try {
                result[i] = codec.decode(src);
            }
            catch (e) {
                throw new errors_1.FunctionResultDecodeError(this.signature, i, e.message, output);
            }
        }
        return result;
    }
    checkSignature(val) {
        return val.startsWith(this.selector);
    }
}
exports.AbiFunction = AbiFunction;
_AbiFunction_selector = new WeakMap();
const fun = (selector, signature, args, returnType) => new AbiFunction(selector, signature, args, returnType, false);
exports.fun = fun;
const viewFun = (selector, signature, args, returnType) => new AbiFunction(selector, signature, args, returnType, true);
exports.viewFun = viewFun;
//# sourceMappingURL=function.js.map