"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.event = exports.AbiEvent = void 0;
const evm_codec_1 = require("@subsquid/evm-codec");
const errors_1 = require("../errors");
class AbiEvent {
    constructor(topic, signature, args) {
        this.topic = topic;
        this.signature = signature;
        this.topicCount = 1;
        this.params = {};
        for (const i in args) {
            const arg = args[i];
            this.params[i] = arg.indexed && arg.isDynamic
                ? {
                    ...evm_codec_1.bytes32,
                    isDynamic: true,
                    indexed: true,
                }
                : arg;
            if (arg.indexed)
                this.topicCount += 1;
        }
    }
    is(rec) {
        return this.checkTopicsCount(rec) && this.checkSignature(rec);
    }
    decode(rec) {
        if (rec.topics.length == 0) {
            throw new errors_1.EventEmptyTopicsError();
        }
        if (!this.checkTopicsCount(rec)) {
            throw new errors_1.EventTopicCountMismatchError({ targetCount: this.topicCount, count: rec.topics.length });
        }
        if (!this.checkSignature(rec)) {
            throw new errors_1.EventInvalidSignatureError({ targetSig: this.topic, sig: rec.topics[0] });
        }
        const src = new evm_codec_1.Src(Buffer.from(rec.data.slice(2), 'hex'));
        const result = {};
        let topicCounter = 1;
        for (let i in this.params) {
            try {
                if (this.params[i].indexed) {
                    const topic = rec.topics[topicCounter++];
                    const topicSrc = new evm_codec_1.Src(Buffer.from(topic.slice(2), 'hex'));
                    result[i] = this.params[i].decode(topicSrc);
                }
                else {
                    result[i] = this.params[i].decode(src);
                }
            }
            catch (e) {
                throw new errors_1.EventDecodingError(this.signature, i, rec.data, e.message);
            }
        }
        return result;
    }
    checkSignature(rec) {
        return rec.topics[0] === this.topic;
    }
    checkTopicsCount(rec) {
        return rec.topics.length === this.topicCount;
    }
}
exports.AbiEvent = AbiEvent;
const event = (topic, signature, args) => new AbiEvent(topic, signature, args);
exports.event = event;
//# sourceMappingURL=event.js.map