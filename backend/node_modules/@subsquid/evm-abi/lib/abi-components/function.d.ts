import { type Codec, type Struct, type DecodedStruct, type EncodedStruct } from '@subsquid/evm-codec';
export interface CallRecord {
    input: string;
}
export type FunctionReturn<T extends AbiFunction<any, any>> = T extends AbiFunction<any, infer R> ? R extends Codec<any, infer U> ? U : R extends Struct ? DecodedStruct<R> : void : never;
export type FunctionArguments<T extends AbiFunction<any, any>> = T extends AbiFunction<infer U, any> ? EncodedStruct<U> : never;
export declare class AbiFunction<const T extends Struct, const R extends Codec<any> | Struct | undefined> {
    #private;
    selector: string;
    signature: string;
    readonly args: T;
    readonly returnType?: R | undefined;
    isView: boolean;
    private readonly slotsCount;
    get sighash(): string;
    constructor(selector: string, signature: string, args: T, returnType?: R | undefined, isView?: boolean);
    is(calldata: string | CallRecord): boolean;
    encode(args: EncodedStruct<T>): string;
    decode(calldata: string | CallRecord): DecodedStruct<T>;
    private isCodecs;
    decodeResult(output: string): FunctionReturn<typeof this>;
    private checkSignature;
}
export declare const fun: <const T extends Struct, const R extends Codec<any, any> | Struct | undefined>(selector: string, signature: string, args: T, returnType?: R | undefined) => AbiFunction<T, R>;
export declare const viewFun: <const T extends Struct, const R extends Codec<any, any> | Struct | undefined>(selector: string, signature: string, args: T, returnType?: R | undefined) => AbiFunction<T, R>;
//# sourceMappingURL=function.d.ts.map